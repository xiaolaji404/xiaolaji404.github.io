<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/xiaolaji.ico"><link rel="icon" href="/img/xiaolaji.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Xiaolaji"><meta name="keywords" content=""><meta name="description" content="总概括 如果将应用程序比作人的身体：所有你所写的那些优雅的代码，业务逻辑，算法，应该就是大脑。垃圾 回收就是应用程序就是相当于人体的腰子，过滤血液中的杂质垃圾，没有腰子，人就会得尿毒症，垃圾 回收器为你的应该程序提供内存和对象。如果垃圾回收器停止工作或运行迟缓,像尿毒症,你的应用程序效 率也会下降，直至最终崩溃坏死。 在C&#x2F;C++中采用用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请"><meta property="og:type" content="article"><meta property="og:title" content="Python垃圾回收机制"><meta property="og:url" content="https://xiaolaji.site/20221001/Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/index.html"><meta property="og:site_name" content="星陨的博客"><meta property="og:description" content="总概括 如果将应用程序比作人的身体：所有你所写的那些优雅的代码，业务逻辑，算法，应该就是大脑。垃圾 回收就是应用程序就是相当于人体的腰子，过滤血液中的杂质垃圾，没有腰子，人就会得尿毒症，垃圾 回收器为你的应该程序提供内存和对象。如果垃圾回收器停止工作或运行迟缓,像尿毒症,你的应用程序效 率也会下降，直至最终崩溃坏死。 在C&#x2F;C++中采用用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xiaolaji.site/Photo/Blog_Photo/index/Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.jpg"><meta property="article:published_time" content="2022-09-30T16:13:00.000Z"><meta property="article:modified_time" content="2023-05-27T14:06:34.000Z"><meta property="article:author" content="Xiaolaji"><meta property="article:tag" content="Python学习"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://xiaolaji.site/Photo/Blog_Photo/index/Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Python垃圾回收机制 - 星陨的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"xiaolaji.site",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:"0eb40f8e6a255579dc28fb908c7f25f5",google:5113481912,gtag:"G-LVS4PR7N6S",tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"btVVcNFUfRauRrpzv6fApy2i-MdYXbMMI",app_key:"e4z3ib7tRXBdPHQR792zwJft",server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>var _hmt;Fluid.ctx.dnt||(_hmt=_hmt||[],function(){var t=document.createElement("script"),e=(t.src="https://hm.baidu.com/hm.js?0eb40f8e6a255579dc28fb908c7f25f5",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}())</script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.google-analytics.com/analytics.js",function(){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","5113481912","auto"),ga("send","pageview")})</script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-LVS4PR7N6S",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-LVS4PR7N6S")})</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="星陨的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>星陨的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>主页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/Photo/Blog_Photo/Banner/Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Python垃圾回收机制"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Xiaolaji </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-01 00:13" pubdate>October 1, 2022 am</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 12 mins </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> views</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Python" id="heading-a7f5f35426b927411fc9231b56382173" role="tab" data-toggle="collapse" href="#collapse-a7f5f35426b927411fc9231b56382173" aria-expanded="true">Python <span class="list-group-count">(22)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-a7f5f35426b927411fc9231b56382173" role="tabpanel" aria-labelledby="heading-a7f5f35426b927411fc9231b56382173"><div class="category-post-list"><a href="/20221001/Python%E4%B8%8E%E5%8D%8F%E7%A8%8B/" title="Python与协程" class="list-group-item list-group-item-action"><span class="category-post">Python与协程</span> </a><a href="/20221001/Python%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="Python与线程" class="list-group-item list-group-item-action"><span class="category-post">Python与线程</span> </a><a href="/20221001/Python%E4%B8%8E%E8%BF%9B%E7%A8%8B/" title="Python与进程" class="list-group-item list-group-item-action"><span class="category-post">Python与进程</span> </a><a href="/20220930/Python%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E6%8E%A8%E5%AF%BC%E5%BC%8F/" title="Python中的各种各样的推导式" class="list-group-item list-group-item-action"><span class="category-post">Python中的各种各样的推导式</span> </a><a href="/20221001/Python%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E5%A4%9A%E6%80%81/" title="Python中的封装与多态" class="list-group-item list-group-item-action"><span class="category-post">Python中的封装与多态</span> </a><a href="/20220930/Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/" title="Python中的模块和包" class="list-group-item list-group-item-action"><span class="category-post">Python中的模块和包</span> </a><a href="/20221001/Python%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/" title="Python中的继承" class="list-group-item list-group-item-action"><span class="category-post">Python中的继承</span> </a><a href="/20220930/Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/" title="Python中的装饰器" class="list-group-item list-group-item-action"><span class="category-post">Python中的装饰器</span> </a><a href="/20220930/Python%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="Python中的递归与二分查找" class="list-group-item list-group-item-action"><span class="category-post">Python中的递归与二分查找</span> </a><a href="/20221001/Python%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98/" title="Python中类的成员" class="list-group-item list-group-item-action"><span class="category-post">Python中类的成员</span> </a><a href="/20220930/Python%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/" title="Python函数用法" class="list-group-item list-group-item-action"><span class="category-post">Python函数用法</span> </a><a href="/20221001/Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="Python垃圾回收机制" class="list-group-item list-group-item-action active"><span class="category-post">Python垃圾回收机制</span> </a><a href="/20221001/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/" title="Python常用模块" class="list-group-item list-group-item-action"><span class="category-post">Python常用模块</span> </a><a href="/20221001/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="Python异常处理" class="list-group-item list-group-item-action"><span class="category-post">Python异常处理</span> </a><a href="/20220905/Python%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/" title="Python操作文件的基本流程" class="list-group-item list-group-item-action"><span class="category-post">Python操作文件的基本流程</span> </a><a href="/20220930/Python%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/" title="Python的内置函数和匿名函数" class="list-group-item list-group-item-action"><span class="category-post">Python的内置函数和匿名函数</span> </a><a href="/20221001/Python%E7%9A%84%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8F%8C%E4%B8%8B%E6%96%B9%E6%B3%95/" title="Python的反射与双下方法" class="list-group-item list-group-item-action"><span class="category-post">Python的反射与双下方法</span> </a><a href="/20220905/Python%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="Python的基础知识" class="list-group-item list-group-item-action"><span class="category-post">Python的基础知识</span> </a><a href="/20221001/Python%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97/" title="Python的套接字" class="list-group-item list-group-item-action"><span class="category-post">Python的套接字</span> </a><a href="/20220930/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" title="Python的迭代器与生成器" class="list-group-item list-group-item-action"><span class="category-post">Python的迭代器与生成器</span> </a><a href="/20221001/Python%E7%B1%BB%E7%9A%84%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" title="Python类的空间问题以及类之间的关系" class="list-group-item list-group-item-action"><span class="category-post">Python类的空间问题以及类之间的关系</span> </a><a href="/20221001/%E5%88%9D%E8%AF%86Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="初识Python面向对象" class="list-group-item list-group-item-action"><span class="category-post">初识Python面向对象</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Python垃圾回收机制</h1><div class="markdown-body"><h1>总概括</h1><p>如果将应用程序比作人的身体：所有你所写的那些优雅的代码，业务逻辑，算法，应该就是大脑。垃圾 回收就是应用程序就是相当于人体的腰子，过滤血液中的杂质垃圾，没有腰子，人就会得尿毒症，垃圾 回收器为你的应该程序提供内存和对象。如果垃圾回收器停止工作或运行迟缓,像尿毒症,你的应用程序效 率也会下降，直至最终崩溃坏死。</p><p>在C/C++中采用<strong>用户自己管理维护内存的方式</strong>。自己管理内存极其自由，可以任意申请内存，但也为大 量内存泄露、悬空指针等bug埋下隐患。</p><p>因此在现在的高级语言（java、C#等）都采用了垃圾收集机制。python也采用了垃圾收集机制。</p><p>Python的垃圾回收机制到底是什么回事？从网上找到一大堆的文档，看的也是一知半解，最终就学会了 一句话</p><p><strong>引用计数器为主、分代回收和标记清除为辅</strong></p><p>但是实际上其内部原理还是有很多复杂地方的。</p><p>引用计数器为主</p><p>标记清除和分代回收为辅+缓存机制</p><h1>一、引用计数器</h1><h2 id="1-1环状的双向链表-Refchain">1.1环状的双向链表(Refchain)</h2><p><img src="image-20220708210741968.png" srcset="/img/loading.gif" lazyload alt="Refchain"></p><p>在python程序中，创建的任何对象都会放在refchain的双向链表中</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;小猪佩奇&quot;</span> <span class="hljs-comment"># 字符串对象</span><br>age = <span class="hljs-number">18</span> <span class="hljs-comment"># 整型对象</span><br>hobby = [<span class="hljs-string">&quot;吸烟&quot;</span>,<span class="hljs-string">&quot;喝酒&quot;</span>,<span class="hljs-string">&quot;烫头&quot;</span>] <span class="hljs-comment"># 列表对象</span><br></code></pre></td></tr></table></figure><p>这些对象都会放到这些双向链表当中，也就是帮忙维护了python中所有的对象。 也就是说如果你得到了refchain,也就得到了python程序中的所有对象。</p><h2 id="1-2不同类型对象的存放形式">1.2不同类型对象的存放形式</h2><p>刚刚提到了<strong>所有的对象都存放在环状的双向链表</strong>中，而不同类型的对象存放在双向链表中既有一些<strong>共性特征</strong>也有一些<strong>不同特征</strong>。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># name = &quot;小猪佩奇&quot;</span><br><span class="hljs-comment"># 创建这个对象时，内部会创建一些数据，并且打包在一起</span><br><span class="hljs-comment"># 哪些数据：【指向上一个对象的指针、指向下一个对象的指针、类型(这里为字符串)、引用的个数】</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">引用的个数:</span><br><span class="hljs-string"></span><br><span class="hljs-string">比如 name = &#x27;小猪佩奇&#x27; ,会给“小猪佩奇”开辟一个内存空间用来存放到双向链表中。</span><br><span class="hljs-string">这时候如果有 new = name，不会创建两个“小猪佩奇”，而是将new指向之前的那个小猪佩奇，</span><br><span class="hljs-string">而引用的个数变为2，也就是&quot;小猪佩奇&quot;这个对象被引用了两次。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><strong>相同点</strong>：刚刚讲到的四个种数据每个对象都包含有。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 内部会创建一些数据，【指向上一个对象的指针、指向下一个对象的指针、类型、引用的个数】</span><br>age = <span class="hljs-number">18</span> <span class="hljs-comment"># 整型对象</span><br><span class="hljs-comment"># 内部会创建一些数据，【指向上一个对象的指针、指向下一个对象的指针、类型、引用的个数】</span><br>hobby = [<span class="hljs-string">&quot;吸烟&quot;</span>,<span class="hljs-string">&quot;喝酒&quot;</span>,<span class="hljs-string">&quot;烫头&quot;</span>] <span class="hljs-comment"># 列表对象</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>不同点：不同的数据类型还会创建不同的值：</p></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 内部会创建一些数据，【指向上一个对象的指针、指向下一个对象的指针、类型、引用的个数、</span><br><span class="hljs-attr">val</span>=<span class="hljs-number">18</span><br><span class="hljs-attr">age</span> = <span class="hljs-number">18</span> <span class="hljs-comment"># 整型对象</span><br><br><span class="hljs-comment"># 内部会创建一些数据，【指向上一个对象的指针、指向下一个对象的指针、类型、引用的个数、</span><br><span class="hljs-attr">items</span>=元素、元素的个数】<br><span class="hljs-attr">hobby</span> = [<span class="hljs-string">&quot;抽烟&quot;</span>,<span class="hljs-string">&quot;喝酒&quot;</span>,<span class="hljs-string">&quot;烫头&quot;</span>] <span class="hljs-comment"># 列表对象</span><br></code></pre></td></tr></table></figure><p>所以在python中创建的对象会加到环形双向链表中，但是每一种类型的数据对象在存到链表中时，所存 放的数据个数可能是不同的（有相同点有不同点）。</p><h3 id="两个重要的结构体">两个重要的结构体</h3><p>Python解释器由c语言开发完成，py中所有的操作最终都由底层的c语言来实现并完成，所以想要了解底 层内存管理需要结合python源码来进行解释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PyObject_HEAD PyObject ob_base ;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PyObject_VAR_HEAD PyVarObject ob_base;</span><br><span class="hljs-comment">//宏定义，包含上一个、下一个，用于构造双向链表用。(放到refchain链表中时，要用到)</span><br><br>#define_PyObject_HEAD_EXTRA \<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">object</span> *_<span class="hljs-title">ob_next</span>;</span> \<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">object</span> *_<span class="hljs-title">ob_prev</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">object</span> &#123;</span><br>	_PyObject_HEAD_EXTRA <span class="hljs-comment">//用于构造双向链表</span><br>	Py_ssize_t ob_refcnt; <span class="hljs-comment">//引用计数器</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">typeobject</span> *<span class="hljs-title">ob_type</span>;</span> <span class="hljs-comment">//数据类型</span><br>&#125; PyObject;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>	PyObject ob_base; <span class="hljs-comment">// PyObject对象</span><br>	Py_ssize_t ob_size; <span class="hljs-comment">/* Number of items in variable part, 即:元素个数*/</span><br>&#125; PyVarObject;<br></code></pre></td></tr></table></figure><p>在C源码中如何体现每个对象中都有的相同的值：PyObject结构体（4个值：ob_next、ob_prev、 ob_refcnt、*ob_type）</p><p>9-13行 定义了一个结构体，第10行实际上就是6，7两行，用来存放前一个对象，和后一个对象的位置。</p><p>这个结构体可以存贮四个值（这四个值是对象都具有的）。</p><p>在C源码中如何体现由多个元素组成的对象：PyObject + ob_size(元素个数)</p><p>15-18行又定义了一个结构体，第16行相当于代指了9-13行中的四个数据。</p><p>而17行又多了一个数据字段，叫做元素个数，这个结构体。</p><p>以上源码是Python内存管理中的基石，其中包含了：</p><ul class="lvl-0"><li class="lvl-2"><p>2个结构体</p></li><li class="lvl-2"><p>PyObject，此结构体中包含3个元素。</p><ul class="lvl-2"><li class="lvl-4">PyObject_HEAD_EXTRA，用于构造双向链表。</li><li class="lvl-4">ob_refcnt，引用计数器。</li><li class="lvl-4">*ob_type，数据类型。</li></ul></li><li class="lvl-2"><p>PyVarObject，次结构体中包含4个元素（ob_base中包含3个元素）</p><ul class="lvl-2"><li class="lvl-4">ob_base，PyObject结构体对象，即：包含PyObject结构体中的三个元素。</li><li class="lvl-4">ob_size，内部元素个数。</li></ul></li></ul><h3 id="类型封装的结构体">类型封装的结构体</h3><p>在我们了解了这两个结构体，现在我们来看看每一个数据类型都封装了哪些值：</p><ul class="lvl-0"><li class="lvl-2"><p>flaot类型</p></li><li class="lvl-2"><p>float结构体：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>	PyObject_HEAD # 这里相当于代表基础的<span class="hljs-number">4</span>个值<br>	<span class="hljs-type">double</span> ob_fval;<br>&#125; PyFloatObject;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">data = <span class="hljs-number">3.14</span><br><br>内部会创建：<br>    _ob_next = refchain中的上一个对象<br>    _ob_prev = refchain中的后一个对象<br>    ob_refcnt = <span class="hljs-number">1</span> 引用个数<br>    ob_type= <span class="hljs-type">float</span> 数据类型<br>    ob_fval = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>int类型</p></li><li class="lvl-2"><p>int结构体：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">longobject</span> &#123;</span><br>	PyObject_VAR_HEAD<br>	digit ob_digit[<span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">// longobject.h</span><br><br><span class="hljs-comment">/* Long (arbitrary precision) integer object interface */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">longobject</span> <span class="hljs-title">PyLongObject</span>;</span> <span class="hljs-comment">/* Revealed in longintrepr.h */</span><br></code></pre></td></tr></table></figure><p>道理都是相同的，第2行代指第二个重要的结构体，第三行是int形特有的值，总结下来就是这个结构体 中有几个值，那么创建这个类型对象的时候内部就会创建几个值。</p><ul class="lvl-0"><li class="lvl-2"><p>list类型</p></li><li class="lvl-2"><p>list结构体：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>	PyObject_VAR_HEAD<br>	<br>    <span class="hljs-comment">/* Vector of pointers to list elements. list[0] is ob_item[0], etc. */</span><br>    PyObject **ob_item;<br><br>    <span class="hljs-comment">/* ob_item contains space for &#x27;allocated&#x27; elements. The number</span><br><span class="hljs-comment">    * currently in use is ob_size.</span><br><span class="hljs-comment">    * Invariants:</span><br><span class="hljs-comment">    * 0 &lt;= ob_size &lt;= allocated</span><br><span class="hljs-comment">    * len(list) == ob_size</span><br><span class="hljs-comment">    * ob_item == NULL implies ob_size == allocated == 0</span><br><span class="hljs-comment">    * list.sort() temporarily sets allocated to -1 to detect mutations.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * Items must normally not be NULL, except during construction when</span><br><span class="hljs-comment">    * the list is not yet visible outside the function that builds it.</span><br><span class="hljs-comment">    */</span><br>    Py_ssize_t allocated;<br>    &#125; PyListObject;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>tuple类型</p></li><li class="lvl-2"><p>tuple结构体:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject_VAR_HEAD<br>    PyObject *ob_item[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">/* ob_item contains space for &#x27;ob_size&#x27; elements.</span><br><span class="hljs-comment">    * Items must normally not be NULL, except during construction when</span><br><span class="hljs-comment">    * the tuple is not yet visible outside the function that builds it.</span><br><span class="hljs-comment">    */</span><br>&#125; PyTupleObject;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>dict类型</p></li><li class="lvl-2"><p>dict结构体:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject_HEAD<br>    Py_ssize_t ma_used;<br>    PyDictKeysObject *ma_keys;<br>    PyObject **ma_values;<br>&#125; PyDictObject;<br></code></pre></td></tr></table></figure><p>到这里我们就学到了什么是环状双向链表，以及双向链表中存放的每一种数据类型的对象都是怎样的。</p><h2 id="1-3引用计数器">1.3引用计数器</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">v1</span> = <span class="hljs-number">3</span>.<span class="hljs-number">14</span><br><span class="hljs-attribute">v2</span> = <span class="hljs-number">999</span><br><span class="hljs-attribute">v3</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>计数器指的就是一个变量，在相同的命名空间内使用的次数，原本调用一次，计数器为1，再次被调用则计数器加1</p><h3 id="计数器减小">计数器减小</h3><p>当发生以下四种情况的时候，该对象的引用计数器+1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a=14 <span class="hljs-comment"># 对象被创建</span><br>b=a <span class="hljs-comment"># 对象被引用</span><br>func(a) <span class="hljs-comment"># 对象被作为参数,传到函数中</span><br>List=[a,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,2] <span class="hljs-comment"># 对象作为一个元素，存储在容器中</span><br>b = 9999 <span class="hljs-comment"># 引用计数器的值为1</span><br>c = b <span class="hljs-comment"># 引用计数器的值为2</span><br></code></pre></td></tr></table></figure><h3 id="计数器减小-2">计数器减小</h3><p>当发生以下四种情况时，该对象的引用计数器-1</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">当该对象的别名被显式销毁时 del <span class="hljs-keyword">a</span><br>当该对象的引别名被赋予新的对象， <span class="hljs-keyword">a</span>=<span class="hljs-number">26</span><br>一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但<br>是全局变量不会）<br>将该元素从容器中删除时，或者容器被销毁时。<br><span class="hljs-keyword">a</span> = <span class="hljs-number">999</span><br>b = <span class="hljs-keyword">a</span> <span class="hljs-comment"># 当前计数器为2</span><br>del b <span class="hljs-comment"># 删除变量b：b对应的对象的引用计数器-1 （此时计数器为1）</span><br>del <span class="hljs-keyword">a</span> <span class="hljs-comment"># 删除变量a：a对应的对象的引用计数器-1 (此时引用计数器为0)</span><br><br>当引用计数器为<span class="hljs-number">0</span> 时，意味着没有人再使用这个对象，这个对象就变成垃圾，垃圾回收。<br>回收：<span class="hljs-number">1.</span>对象从refchain的链表移除。<br><span class="hljs-number">2.</span>将对象进行销毁，内存归还给操作系统，可用内存就增加。<br></code></pre></td></tr></table></figure><p>当引用计数器为0 时，意味着没有人再使用这个对象，这个对象就变成垃圾，垃圾回收。</p><p>回收：</p><ol><li class="lvl-3"><p>对象从refchain的链表移除。</p></li><li class="lvl-3"><p>将对象进行销毁，内存归还给操作系统，可用内存就增加。</p></li></ol><p>以上就是引用计数器大体上的机制，但是后面的缓存机制学习完之后我们才会进一步理解，这里不是简 单的说计数器等于0就销毁，内部还有一定的缓冲，目前就简单理解成计数器为0，我们就进行垃圾回收。</p><p>例子</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-string">&quot;雷霆嘎巴&quot;</span> <span class="hljs-comment"># 创建对象并初始话引用计数器为1</span><br><span class="hljs-attr">b</span> = a <span class="hljs-comment"># 计数器发生变化</span><br><span class="hljs-attr">c</span> = a<br><span class="hljs-attr">d</span> = a<br><span class="hljs-attr">e</span> = a<br><br><span class="hljs-attr">f</span> = <span class="hljs-string">&quot;小猪佩奇&quot;</span> <span class="hljs-comment"># 创建对象并初始话引用计数器为1</span><br></code></pre></td></tr></table></figure><p><img src="image-20220708213627115.png" srcset="/img/loading.gif" lazyload alt="例程的示意图"></p><p>当我们将&quot;雷霆嘎巴&quot;的对象的引用计数器减小至0时，就将其移除，并且相邻两边直接连接。</p><h2 id="1-4循环引用问题">1.4循环引用问题</h2><p>一种编程语言利用引用计数器实现垃圾管理和回收，已经是比较完美的了，只要计数器为0就回收，不为 0就不回收，即简单明了，又能实现垃圾管理。</p><p>一种编程语言利用引用计数器实现垃圾管理和回收，已经是比较完美的了，只要计数器为0就回收，不为 0就不回收，即简单明了，又能实现垃圾管理。</p><p>例子：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">v1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] # refchain中创建一个列表对象，由于<span class="hljs-built_in">v1</span>=对象，所以列表引对象引用计数<br>器为<span class="hljs-number">1</span>.<br><span class="hljs-symbol">v2</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] # refchain中再创建一个列表对象，因<span class="hljs-built_in">v2</span>=对象，所以列表对象引用计数器<br>为<span class="hljs-number">1</span>.<br><span class="hljs-symbol">v1.append</span>(<span class="hljs-built_in">v2</span>) # 把<span class="hljs-built_in">v2</span>追加到<span class="hljs-built_in">v1</span>中，则<span class="hljs-built_in">v2</span>对应的[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]对象的引用计数器加<span class="hljs-number">1</span>，最终为<span class="hljs-number">2</span>.<br><span class="hljs-symbol">v2.append</span>(<span class="hljs-built_in">v1</span>) # 把<span class="hljs-built_in">v1</span>追加到<span class="hljs-built_in">v1</span>中，则<span class="hljs-built_in">v1</span>对应的[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]对象的引用计数器加<span class="hljs-number">1</span>，最终为<span class="hljs-number">2</span>.<br><br><span class="hljs-symbol">del</span> <span class="hljs-built_in">v1</span> # 引用计数器-<span class="hljs-number">1</span><br><span class="hljs-symbol">del</span> <span class="hljs-built_in">v2</span> # 引用计数器-<span class="hljs-number">1</span><br><br>最终<span class="hljs-built_in">v1</span>,<span class="hljs-built_in">v2</span>引用计数器都是<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其实就是因为两个容器相互引用，无中生有，两个空的，引用后本来也应该是空的，但是计数器不存在空的情况，所以导致出现bug</p><p>两个引用计数器现在都是1，那么它们都不是垃圾所以都不会被回收，但如果是这样的话，我们的代码就 会出现问题。</p><p>我们删除了v1和v2，那么就没有任何变量指向这两个列表，那么这两个列表之后程序运行的时候都无法 再使用，但是这两个列表的引用计数器都不为0，所以不会被当成垃圾进行回收，所以这两个列表就会一 直存在在我们的内存中，永远不会销毁，当这种代码越来越多时，我们的程序一直运行，内存就会一点 一点被消耗，然后内存变满，满了之后就爆栈了。这时候如果重新启动程序或者电脑，这时候程序又会 正常运行，其实这就是因为循环引用导致数据没有被及时的销毁导致了内存泄漏。</p><h2 id="1-5总结">1.5总结</h2><h3 id="优点">优点</h3><ul class="lvl-0"><li class="lvl-2"><p>简单</p></li><li class="lvl-2"><p>实时性：一旦没有引用，内存就直接释放了。 不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时</p></li></ul><h3 id="缺点">缺点</h3><ul class="lvl-0"><li class="lvl-2"><p>维护引用计数消耗资源</p></li><li class="lvl-2"><p>循环引用：对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制（标记清除和分代收集）。</p></li></ul><h1>二、标记清除</h1><h2 id="2-1引入目的">2.1引入目的</h2><p>为了解决循环引用的不足，python的底层不会单单只用引用计数器，引入了一个机制叫做标记清除</p><h2 id="2-2实现原理">2.2实现原理</h2><p>在python的底层中，再去维护一个链表，这个链表中专门放那些可能存在循环引用的对象。</p><p>就是那些元素里面可以存放其他元素的元素。（list/dict/tuple/set，甚至class）</p><p>例如：</p><p><img src="image-20220708214702886.png" srcset="/img/loading.gif" lazyload alt="例程"></p><p>第二个链表 <strong>只存储可能是循环引用的对象</strong>。</p><p>维护两个链表的作用是，在python内部某种情况下，会去扫描 可能存在循环引用的链表 中的每个元素， 在循环一个列表的元素时，由于内部还有子元素 ，如果存在循环引用(v1 = [1,2,3,v2]和v2 = [4,5,6,v1])， 比如从v1的子元素中找到了v2，又从v2的子元素中找到了v1，那么就检查到循环引用，如果有循环引 用，就让双方的引用计数器各自-1，如果是0则垃圾回收。</p><h2 id="2-3标记清除算法">2.3标记清除算法</h2><p>【标记清除（Mark—Sweep）】算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它 分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标 记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成 这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标 记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p><p><img src="image-20220708214808049.png" srcset="/img/loading.gif" lazyload alt="标记清除法示意图"></p><p>在上图中，我们把小黑点视为全局变量，也就是把它作为root object，从小黑点出发，对象1可直达， 那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5 是非活动对象会被GC回收。</p><ol><li class="lvl-3"><p>寻找跟对象（root object）的集合作为垃圾检测动作的起点，跟对象也就是一些全局引用和函数栈 中的引用，这些引用所指向的对象是不可被删除的。</p></li><li class="lvl-3"><p>从root object集合出发，沿着root object集合中的每一个引用，如果能够到达某个对象，则说明这 个对象是可达的，那么就不会被删除，这个过程就是垃圾检测阶段。</p></li><li class="lvl-3"><p>当检测阶段结束以后，所有的对象就分成可达和不可达两部分，所有的可达对象都进行保留，其它 的不可达对象所占用的内存将会被回收，这就是垃圾回收阶段。（底层采用的是链表将这些集合的 对象连接在一起）。</p></li></ol><h1>三、分代回收</h1><h2 id="3-1引入目的">3.1引入目的</h2><ul class="lvl-0"><li class="lvl-2"><p>什么时候扫描去检测循环引用？</p></li><li class="lvl-2"><p>标记和清除的过程效率不高。清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分 活动对象也要扫描所有对象。</p></li></ul><p>为了解决这些问题，python引入了分代回收</p><h2 id="3-2原理">3.2原理</h2><p>将第二个链表（可能存在循环引用的链表），维护成3个环状双向的链表：</p><ul class="lvl-0"><li class="lvl-2"><p>0代： 0代中对象个数达到700个，扫描一次。</p></li><li class="lvl-2"><p>1代： 0代扫描10次，则1代扫描1次</p></li><li class="lvl-2"><p>2代： 1代扫描10次，则2代扫描1次。</p></li></ul><p><img src="image-20220708215118291.png" srcset="/img/loading.gif" lazyload alt="示意图"></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 分代的C源码</span><br><span class="language-xml">#define NUM_GENERATIONS 3</span><br><span class="language-xml">struct gc_generation generations[NUM_GENERATIONS] = &#123;</span><br><span class="language-xml">/* PyGC_Head, threshold, count */</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;(<span class="hljs-name">uintptr_t</span>)_GEN_HEAD(<span class="hljs-name">0</span>), (<span class="hljs-name">uintptr_t</span>)_GEN_HEAD(<span class="hljs-name">0</span>)&#125;, <span class="hljs-number">700</span>, <span class="hljs-number">0</span>&#125;, //</span><br><span class="hljs-template-variable"><span class="hljs-number">0</span>代</span><br><span class="hljs-template-variable">&#123;&#123;(<span class="hljs-name">uintptr_t</span>)_GEN_HEAD(<span class="hljs-name">1</span>), (<span class="hljs-name">uintptr_t</span>)_GEN_HEAD(<span class="hljs-name">1</span>)&#125;, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>&#125;, //</span><br><span class="hljs-template-variable"><span class="hljs-number">1</span>代</span><br><span class="hljs-template-variable">&#123;&#123;(<span class="hljs-name">uintptr_t</span>)_GEN_HEAD(<span class="hljs-name">2</span>), (<span class="hljs-name">uintptr_t</span>)_GEN_HEAD(<span class="hljs-name">2</span>)&#125;, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>&#125;, //</span><br><span class="hljs-template-variable"><span class="hljs-number">2</span>代</span><br><span class="hljs-template-variable">&#125;;</span><br></code></pre></td></tr></table></figure><p>例：</p><p><img src="image-20220708215208695.png" srcset="/img/loading.gif" lazyload alt="环形双向链表"></p><ul class="lvl-0"><li class="lvl-2"><p>当我们创建一个对象val = 19,那么它只会加到refchain链表中。</p></li><li class="lvl-2"><p>当我们创建一个对象v1 = [11,22],除了加到refchain，那么它会加到0代链表中去。</p></li><li class="lvl-2"><p>如果再创建一个对象v2 = [33,44],那么它还是往0代添加。</p></li></ul><p>直到0代中的个数达到700之后，就会对0代中的所有元素进行一次扫描，扫描时如果检测出是循环引用 那么引用计数器就自动-1，然后判断引用计数器是否为0，如果为0，则为垃圾就进行回收。不是垃圾的 话，就对该数据进行升级，从0代升级到1代，这个时候0代就是空，1代就会记录一下0代已经扫描1次， 然后再往0代中添加对象直到700再进行一次扫描，不停反复，直到0代扫描了10次，才会对1代进行1次扫描。</p><p>分代回收解决了标记清楚时什么时候扫描的问题，并且将扫描的对象分成了3级，以及降低扫描的工作 量，提高效率</p><h2 id="3-3弱代假说">3.3弱代假说</h2><p>为什么要按一定要求进行分代扫描？</p><p>这种算法的根源来自于弱代假说(weak generational hypothesis)。</p><p>这个假说由两个观点构成：<strong>首先是年轻的对象通常死得也快，而老对象则很有可能存活更长的时间</strong></p><p>假定现在我用Python创建一个新对象 n1=“ABC”</p><p>根据假说，我的代码很可能仅仅会使用ABC很短的时间。这个对象也许仅仅只是一个方法中的中间结 果，并且随着方法的返回这个对象就将变成垃圾了。大部分的新对象都是如此般地很快变成垃圾。然而，偶尔程序会创建一些很重要的，存活时间比较长的对象，例如web应用中的session变量或是配置项。</p><p>频繁的处理零代链表中的新对象，可以将让Python的垃圾收集器把时间花在更有意义的地方：它处理那些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足一定的条件，收集器才回去处理那些老变量</p><h1>四、总结</h1><p>在python中维护了refchain的双向环状链表，这个链表中存储创建的所有对象，而每种类型的对象中， 都有一个ob_refcnt引用计数器的值，它维护者引用的个数+1,-1,最后当引用计数器变为0时，则进行垃圾回收（对象销毁、refchain中移除）。</p><p>但是，在python中对于那些可以有多个元素组成的对象，可能会存在循环引用的问题，并且为了解决这 个问题，python又引入了标记清除和分代回收，在其内部维护了4个链表，分别是：</p><ul class="lvl-0"><li class="lvl-2"><p>refchain</p></li><li class="lvl-2"><p>2代，10次</p></li><li class="lvl-2"><p>1代，10次</p></li><li class="lvl-2"><p>0代，700个</p></li></ul><p>在源码内部，当达到各自的条件阈值时，就会触发扫描链表进行标记清除的动作（如果有循环引 用，引用计数器就各自-1）。</p><p>但是，源码内部在上述的流程中提出了优化机制，就是缓存机制。</p><h1>五、缓存机制</h1><p>缓存在python中分为两大类</p><h2 id="5-1池">5.1池</h2><p>在python中为了避免重复创建和销毁一些常见对象，维护池。</p><p>例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">v1</span> = <span class="hljs-number">7</span><br><span class="hljs-attr">v2</span> = <span class="hljs-number">9</span><br><span class="hljs-attr">v3</span> = <span class="hljs-number">9</span><br><br><span class="hljs-comment"># 按理说在python中会创建3个对象，都加入refchain中。</span><br></code></pre></td></tr></table></figure><p>然而python在启动解释器时，python认为-5、-4、…… 、256，bool、一定规则的字符串，这些值都是 常用的值，所以就会在内存中帮你先把这些值先创建好，接下来进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动解释器时，python内部帮我们创建-5、-4、...255、256的整数和一定规则的字符串</span><br>v1 = 9 <span class="hljs-comment"># 内部不会开辟内存，直接去池中获取</span><br>v2 = 9 <span class="hljs-comment"># 同上，都是去数据池里直接拿9，所以v1和v2指向的内存地址是一样的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(v1),<span class="hljs-built_in">id</span>(v2))<br><br>v3 = 256 <span class="hljs-comment"># 内部不会开辟内存，直接去池中获取</span><br>v4 = 256 <span class="hljs-comment"># 同上，都是去数据池里直接拿256，所以v3和v4指向的内存地址是一样的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(v3),<span class="hljs-built_in">id</span>(4))<br><br>v5 = 257<br>v6 = 257<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(v5),<span class="hljs-built_in">id</span>(v6))<br></code></pre></td></tr></table></figure><p>排查原因：版本不同，小数据池扩大。</p><p>在交互模式下返回得结果符合预期，文件模式的情况下</p><p>问题：为什么交互模式和命令模式结果有区别？</p><p>答：因为代码块的缓存机制。</p><ul class="lvl-0"><li class="lvl-2"><p>什么是代码块？</p></li></ul><p>一个模块、一个函数、一个类、一个文件等都是一个代码块；交互式命令下，一行就是一个代码块。</p><ul class="lvl-0"><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">同一个代码块内的缓存机制（字符串驻留机制）</li><li class="lvl-4">机制内容：Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存 在，如果存在，会将其重用，即将两个变量指向同一个对象。换句话说：执行同一个代码块 时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的 变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这 个值。所以在用命令模式执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足 缓存机制则他们在内存中只存在一个，即：id相同。</li></ul></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">适用对象： int（float），str，bool。</li><li class="lvl-4">对象的具体细则：（了解）</li><li class="lvl-4">int(float)：任何数字在同一代码块下都会复用。</li><li class="lvl-4">bool：True和False在字典中会以1，0方式存在，并且复用。</li><li class="lvl-4">str：几乎所有的字符串都会符合字符串驻留机制</li></ul></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 同一个代码块内的缓存机制————任何数字在同一代码块下都会复用</span><br>i1 = 1000<br>i2 = 1000<br><span class="hljs-built_in">print</span>(id(i1))<br><span class="hljs-built_in">print</span>(id(i2))<br>输出结果：<br><br><br><br><span class="hljs-comment"># 同一个代码块内的缓存机制————几乎所有的字符串都会符合缓存机制</span><br>s1 = <span class="hljs-string">&#x27;hfdjka6757fdslslgaj@!#fkdjlsafjdskl;fjds中国&#x27;</span><br>s2 = <span class="hljs-string">&#x27;hfdjka6757fdslslgaj@!#fkdjlsafjdskl;fjds中国&#x27;</span><br><span class="hljs-built_in">print</span>(id(s1))<br><span class="hljs-built_in">print</span>(id(s2))<br>输出结果：<br><br><br><br><span class="hljs-comment"># 同一个代码块内的缓存机制————非数字、str、bool类型数据，指向的内存地址一定不同</span><br>t1 = (1,2,3)<br>t2 = (1,2,3)<br>l1 = [1,2,3]<br>l2 = [1,2,3]<br><span class="hljs-built_in">print</span>(id(t1))<br><span class="hljs-built_in">print</span>(id(t2))<br><span class="hljs-built_in">print</span>(id(l1))<br><span class="hljs-built_in">print</span>(id(l2))<br>输出结果：<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>不同代码块间的缓存机制（小数据池、小整数缓存机制、小整数驻留机制）</p></li><li class="lvl-2"><p>适用对象： int（float），str，bool</p></li><li class="lvl-2"><p>具体细则：-5~256数字，bool，满足一定规则的字符串。</p><ul class="lvl-2"><li class="lvl-4"><p>优点：提升性能，节省内存。</p></li><li class="lvl-4"><p>Python自动将-5~256的整数进行了缓存，当你将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。</p></li><li class="lvl-4"><p>python会将一定规则的字符串在字符串驻留池中，创建一份，当你将这些字符串赋值给变量 时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。</p></li><li class="lvl-4"><p>其实，无论是缓存还是字符串驻留池，都是python做的一个优化，就是将~5-256的整数，和一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中那些变量指向这些范围内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存中之创建一个。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建文件1: file1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">A</span>():<br>b = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b))<br><span class="hljs-comment"># 创建文件2: file2</span><br><span class="hljs-keyword">from</span> file1 <span class="hljs-keyword">import</span> A<br>a = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a))<br>A()<br></code></pre></td></tr></table></figure><p>总结一下就是，**同一个代码块中(交互模式中的)**因为字符串驻留机制，int（float），str，bool这些数据类型，只要对象相同，那么内存地址共享。</p><p>而不同代码块中只有引用对象为**-5~256整数，bool，满足一定规则的字符串**，才会有内存共享，即id相同。</p><p>并且这些python编辑器初始化的数据，他们的引用计数器永远不会为0,在初始化的时候就会将引用计数器默认设置为1。</p><h2 id="5-2-free-list">5.2 free_list</h2><p>当一个对象的引用计数器为0的时候，按理说应该回收，但是在python内部为了优化，不会去回收，而是将对象添加到free_list链表中当作缓存。以后再去创建对象时就不再重新开辟内存，而是直接使用 free_list。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">v1</span> = <span class="hljs-number">3</span>.<span class="hljs-number">14</span> # 创建float型对象，加入refchain，并且引用计数器的值为<span class="hljs-number">1</span><br><span class="hljs-attribute">del</span> v1 #refchain中移除，按理说应该销毁，但是python会将对象添加到free_list中。<br><br><span class="hljs-attribute">v2</span> = <span class="hljs-number">9</span>.<span class="hljs-number">999</span> # 就不会重新开辟内存，去free_list中获取对象，对象内部数据初始化，再放到<br><span class="hljs-attribute">refchain</span>中。<br></code></pre></td></tr></table></figure><p>但是free_list也是有容量的，不是无限收纳, 假设默认数量为80，只有当free_list满的时候，才会直接去销毁。</p><p>代表性的有float/list/tuple/dict，这些数据类型都是以free_list方式来进行回收的。</p><p>缓存列表对象的创建源码：</p><p>总结一下，就是引用计数器为0的时候，有的是直接销毁，而有些需要先加入缓存当中的。</p><p>每个数据类型的缓存链表源码详见：</p><p>[<a target="_blank" rel="noopener" href="https://pythonav.com/wiki/detail/6/88/#2.4%20int%E7%B1%BB%E5%9E%8B">https://pythonav.com/wiki/detail/6/88/#2.4 int类型</a>]</p><p><a target="_blank" rel="noopener" href="https://pythonav.com/wiki/detail/6/88/#2.4">https://pythonav.com/wiki/detail/6/88/#2.4</a></p><h1>C源码分析</h1><p>arena 是 CPython 的内存管理结构之一。代码在 Python/pyarena.c 中其中包含了 C 的内存分配和解 除分配的方法。</p><p><a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Python/pyarena.c">https://github.com/python/cpython/blob/master/Python/pyarena.c</a></p><p>Modules/gcmodule.c ，该文件包含垃圾收集器算法的实现。</p><p><a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c">https://github.com/python/cpython/blob/master/Modules/gcmodule.c</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Python/" class="category-chain-item">Python</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Python%E5%AD%A6%E4%B9%A0/">#Python学习</a></div></div><div class="license-box my-3"><div class="license-title"><div>Python垃圾回收机制</div><div>https://xiaolaji.site/20221001/Python垃圾回收机制/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>Xiaolaji</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>October 1, 2022</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - Share-alike"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/20221001/%E5%88%9D%E8%AF%86Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="初识Python面向对象"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">初识Python面向对象</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/20221001/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="Python异常处理"><span class="hidden-mobile">Python异常处理</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments("#waline",function(){Fluid.utils.createCssLink("https://lib.baomitu.com/waline/2.14.1/waline.min.css"),Fluid.utils.createScript("https://lib.baomitu.com/waline/2.14.1/waline.min.js",function(){var i=Object.assign({serverURL:"https://api.xiaolaji.site/",path:"window.location.pathname",meta:["nick","mail","link"],requiredMeta:["nick"],lang:"zh-CN",emoji:["https://unpkg.com/@waline/emojis@1.1.0/tw-emoji"],dark:'html[data-user-color-scheme="dark"]',wordLimit:0,pageSize:10},{el:"#waline",path:window.location.pathname});Waline.init(i),Fluid.utils.waitElementVisible("#waline .vcontent",()=>{var i="#waline .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">Views: <span id="busuanzi_value_site_pv"></span> </span><span id="busuanzi_container_site_uv" style="display:none">Visitors: <span id="busuanzi_value_site_uv"></span></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">苏ICP备2022037338号-1</a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>